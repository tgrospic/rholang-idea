{
  parserClass="coop.rchain.lang.RhoParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Rho"
  psiImplClassSuffix="Impl"
  psiPackage="coop.rchain.lang.psi"
  psiImplPackage="coop.rchain.lang.psi.impl"

  elementTypeHolderClass="coop.rchain.lang.psi.RhoTypes"
  elementTypeClass="coop.rchain.lang.psi.RhoElementType"
  tokenTypeClass="coop.rchain.lang.psi.RhoTokenType"

  tokens = [
    CONTRACT = "contract"
    SELECT = "select"
    MATCH = "match"
    TOTAL = "total"
    CASE = "case"
    WITH = "with"
    DEF = "def"
    FOR = "for"
    LET = "let"
    NEW = "new"
    SUM = "sum"
    IF = "if"
    IN = "in"
    FALSE = "false"
    TRUE = "true"
    NIL = "Nil"

    FAT_ARROW = "=>"
    THIN_ARROW = "->"
    DOT = "."

    BITWISE_AND = "&"
    BITWISE_OR = "|"
    BITWISE_XOR = "^"

    TRIPLE_DOT = "..."
    DOUBLE_DOT = ".."
    DOUBLE_COLON = "::"
    COLON = ":"

    PLUS = "+"
    MINUS = "-"
    MULTIPLY = "*"
    DIVIDE = "/"
    REMAINDER = "%"

    ASSIGN_LEFT_SHIFT = "<<="
    ASSIGN_RIGHT_SHIFT = ">>="
    EQUAL = "=="
    ASSIGN = "="
    NOT_EQUAL = "!="
    LESS_THAN_OR_EQUAL = "<="
    LESS_THAN = "<"
    GREATER_THAN_OR_EQUAL = ">="
    GREATER_THAN = ">"

    NOT = "!"
    BOX = "~"
    AT = "@"
    SINGLE_QUOTE = "'"
    DOLLAR = "$"

    HASH = "#"
    OPEN_SQUARE_BRACKET = "["
    CLOSE_SQUARE_BRACKET = "]"
    OPEN_PAREN = "("
    CLOSE_PAREN = ")"
    OPEN_BRACE = "{"
    CLOSE_BRACE = "}"
    COMMA = ","
    SEMICOLON = ";"
    UNDERSCORE = "_"

    // Variables
    VAR = 'regexp: [a-zA-Z_][a-zA-Z_0-9]*'
  ]

//  psiImplUtilClass="coop.rchain.psi.impl.RhoPsiImplUtil"
//  consumeTokenMethod("Proc.*|Proc")="consumeTokenFast"

//  extends(".*Quantity")=Quantity
}

// Top level process declaration
RootProc ::= Proc

// Processes
private Proc4 ::= NIL | Value
private Proc3 ::= ChanRefSymbol Chan [ProcParen]
private Proc2 ::= Chan "!" ProcParen
private Proc1 ::= FOR BindParen ProcBlock
                | CONTRACT ContractName "(" [CPattern] ")" "=" ProcBlock
                | CONTRACT ContractName "=" TypeTerm // experimental
                | SELECT CBranchBlock
                | MatchWith
                | NEW [VarPattern] IN ProcBlock
                | NEW [VarPattern] IN Proc
                | LET ("(" CPattern ")" | CPattern) "=" Proc IN Proc
                | ConstrName ProcParen
                | AtVar ProcParen
                | "@" VAR

private
Proc_ ::= (Proc1 | Proc2 | Proc3 | Proc4 | ConstrName) [TypePattern] | comment
Proc  ::= Proc_ (("|" | "," | "." | "!")? Proc_)*

ProcBlock    ::= "{" [Proc] "}"
ProcParen    ::= "(" [Proc] ")"
ProcBracket  ::= "[" [Proc] "]"

CBranchBlock ::= "{" [CBranch] "}"
BindParen    ::= "(" [Bind] ")"
MatchWith    ::= MATCH Proc "{" [PMBranch] "}"

ChanRefSymbol ::= "*" {
  implements = [ "coop.rchain.lang.psi.RhoNamedElement" ]
  mixin = "coop.rchain.lang.psi.RhoNamedElementImpl"
}

ContractName ::= AtVar {
  implements = [ "coop.rchain.lang.psi.RhoNamedElement" ]
  mixin = "coop.rchain.lang.psi.RhoNamedElementImpl"
}

ConstrName ::= AtVar {
  implements = [ "coop.rchain.lang.psi.RhoNamedElement" ]
  mixin = "coop.rchain.lang.psi.RhoNamedElementImpl"
}

// Channels
Chan ::= "@" Proc3 | AtVar {
  implements = [ "coop.rchain.lang.psi.RhoNamedElement" ]
  mixin = "coop.rchain.lang.psi.RhoNamedElementImpl"
}

private
AtVar ::= ["@"] VAR
        | ["@"] stringLit
        | ["@"] "{" Proc "}"

// Variable binding
private
Bind_ ::= CPattern ("<-"|"<=") Chan IF Proc
        | CPattern ("<-"|"<=") Chan
        | ValPattern
        | VarPattern
Bind  ::= Bind_ (";" Bind_)*

// Pattern match branches
private
PMBranch_ ::= PPattern "=>" ProcBlock
PMBranch  ::= PMBranch_ PMBranch_*

// Choice branch
private
CBranch_ ::= [Bind] "=>" ProcBlock
CBranch  ::= CBranch_ CBranch_*

QVal ::= TRUE
       | FALSE
       | numericLit
       | stringLit
       | VAR ["." Proc]

// Quantity
private
Quantity_ ::= ("-"|"+") Quantity_
  | ProcParen
  | ProcBracket
  | ProcBlock
  | QVal
Quantity ::= Quantity_ (("*"|"/"|"+"|"-"|"<="|"<"|">="|">"|"=="|"!="|"&&"|"||") Quantity_)*

// Values
Value ::= Quantity

// Variable patterns
private
VarPattern_ ::= ["@"] (VAR | "_") [TypePattern]
VarPattern  ::= VarPattern_ ("," VarPattern_)*

// Process patterns
private
PPattern_ ::= VarPattern | ValPattern
PPattern  ::= PPattern_ ("," PPattern_)*

// Channel patterns
CPattern_ ::= VarPattern
            | ValPattern {
  implements = [ "coop.rchain.lang.psi.RhoNamedElement" ]
  mixin = "coop.rchain.lang.psi.RhoNamedElementImpl"
}
CPattern  ::= CPattern_ ("," CPattern_)*

// Bind pattern
private
PatternBind_ ::= CPattern "<-" CPattern
PatternBind  ::= PatternBind_ (";" PatternBind_)*

// Pattern match branch pattern
private
PatternPatternMatch_ ::= PPattern "=>" "{" PPattern "}"
PatternPatternMatch  ::= PatternPatternMatch_ PatternPatternMatch_*

// Value patterns
private
ValPattern1 ::= "[" [PPattern] "]"
              | TRUE
              | FALSE
              | numericLit
              | stringLit
private
ValPattern2 ::= ["@"] ValPattern1
ValPattern  ::= ValPattern2 ("," ValPattern2)*

// Primitive types
private numericLit ::= '-'? (BIN_LIT | OCT_LIT | HEX_LIT | DEC_LIT)
private stringLit  ::= STRING_LIT | RAW_STRING_LIT | CHAR_LIT
private comment    ::= (BLOCK_COMMENT|BLOCK_DOC_COMMENT|LINE_COMMENT|LINE_DOC_COMMENT)

// Type patterns (experimental)
TypeTerm ::= (VAR) [TypeGeneric] {
  implements = [ "coop.rchain.lang.psi.RhoNamedElement" ]
  mixin = "coop.rchain.lang.psi.RhoNamedElementImpl"
}
TypeGeneric ::= "<" [TypeTerm] ">"
              | "[" [TypeTerm] "]"
              | "(" [TypeTerm_] ")"
private
TypeTerm_   ::= TypeTerm ("," TypeTerm)*
TypePattern ::= ":" TypeTerm
